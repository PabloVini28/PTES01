# PROGRAMMING TECHNIQUES FOR EMBEDDED SYSTEMS I

## AP01 -游닇
    01 - #define gpio_enabled     (1<<0)
         #define gpio_direction    (1<<1) // output:1 input:0
         #define gpio_level          (1<<2)
         #define gpio_reset         (1<<3)
          
         int main(){
            unsigned char gpioREG;
         }
          
         ==================================
          
         a) Escrever a l칩gica bin치ria para setar a vari치vel gpioREG como habilitado (gpio_enabled).
         b) Escrever a l칩gica bin치ria para testar se a vari치vel gpioREG foi definido como sa칤da (gpio_direction), caso positivo voc칡 deve desabilitar (gpio_enabled).
         c) Escrever a logica bin치ria para setar a vari치vel gpioREG como entrada (gpio_direction).
         d) Escrever a logica bin치ria para alterar o gpioREG como n칤vel alto (gpio_level) ou n칤vel baixo. Ex: se ele estava como alto passar para baixo e vice-versa)
##
    02 - Escreva um programa que pegue os bits em um n칰mero e 
         os desloque para a extremidade esquerda.
         
         Exemplo:
         entrada: 86 (decimal)
         sa칤da: 11110000 (bin치rio).
##
    03 - Escreva um c칩digo que contenha a seguinte fun칞칚o "int countBits(bool w,unsigned int value)", com par칙metros w (booleano) e value (inteiro e positivo de 32 bits)
         e que retorne a quantidade de bits w que est칚o definidos em value.
         
         Exemplo:
         num = countBits(1, 7); // para w=1 e value =7, ent칚o num recebe 3, caso w=0, ent칚o num deve ser 29.
##
    04 - Escreva um c칩digo que contenha uma fun칞칚o int setBits(bool w, unsigned int i, unsigned int j, unsigned int value) que 
         sete n bits, definido pelo intervalo i e j, com o valor de w (0 ou 1) na vari치vel value e o resultado jogue no retorno.
         
         Exemplo:
         num = setBits(1, 1, 2, 8) //logo num recebe 14 .
         obs.: Verifique os limites para garantir que i e j est칚o dentro do intervalo 0-31.
##
    05 - Escreva um programa em C que receba cinco par칙metros: num (o n칰mero a ser rotacionado), 
         n (o n칰mero de passos a ser realizada), i e f (os 칤ndices i de in칤cio e f de fim s칚o os limites de 
         rota칞칚o, em que o 0 representa o bit menos significativo e 31 o bit mais significativo), 
         e d (a dire칞칚o da rota칞칚o, onde 1 significa direita e 0 significa esquerda). O programa deve realizar 
         a rota칞칚o do n칰mero [num] no intervalo especificado [i, f], na dire칞칚o especificada por [d], [n] vezes, 
         considerando que para cada rota칞칚o o bit que sai pela esquerda deve entrar pela direita e vice-versa.
    
         Exemplo de entrada e sa칤da esperada:
    
         Entrada:
         num = 53 (00110101 em bin치rio)
         n = 2
         i = 2
         f = 5
         d = 1
        
         Sa칤da esperada: 29(00011101 em binario)
         
          


